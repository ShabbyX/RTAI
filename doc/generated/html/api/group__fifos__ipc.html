<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>RTAI API: Inter-process communications.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="globals.html">Globals</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>Inter-process communications.<br>
<small>
[<a class="el" href="group__fifos.html">RTAI FIFO module</a>]</small>
</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
RTAI FIFO communication functions. 
<p>
RTAI fifos maintain full compatibility with those available in NMT_RTLinux while adding many other useful services that avoid the clumsiness of Unix/Linux calls. So if you need portability you should bent yourself to the use of select for timing out IO operations, while if you have not to satisfy such constraints use the available simpler, and more direct, RTAI fifos specific services.<p>
In the table below the standard Unix/Linux services in user space are enclosed in []. See standard Linux man pages if you want to use them, they need not be explained here.<p>
<center><table border="1" cellspacing="3" cellpadding="3">
<tr>
<td>Called from RT task </td><td>Called from Linux process  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga8">rtf_create</a> </td><td><a class="el" href="group__fifos__ipc.html#ga1">rtf_open_sized</a> <br>
 [open]  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga9">rtf_destroy</a> </td><td>[close]  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga6">rtf_reset</a> </td><td><a class="el" href="group__fifos__ipc.html#ga6">rtf_reset</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga7">rtf_resize</a> </td><td><a class="el" href="group__fifos__ipc.html#ga7">rtf_resize</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga12">rtf_get</a> </td><td>[read] <br>
 <a class="el" href="group__fifos__ipc.html#ga3">rtf_read_timed</a> <br>
 <a class="el" href="group__fifos__ipc.html#ga2">rtf_read_all_at_once</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga11">rtf_put</a> </td><td>[write] <br>
 <a class="el" href="group__fifos__ipc.html#ga4">rtf_write_timed</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga10">rtf_create_handler</a> </td><td></td></tr>
<tr>
<td></td><td><a class="el" href="group__fifos__ipc.html#ga0">rtf_suspend_timed</a>  </td></tr>
<tr>
<td></td><td><a class="el" href="group__fifos__ipc.html#ga5">rtf_set_async_sig</a>  </td></tr>
</table>
</center><p>
In Linux, fifos have to be created by : <div class="fragment"><pre class="fragment"> $ mknod /dev/rtf&lt;x&gt; c 150 &lt;x&gt; </pre></div>where &lt;x&gt; is the minor device number, from 0 to 63; thus on the Linux side RTL fifos can be used as standard character devices. As it was said above to use standard IO operations on such devices there is no need to explain anything, go directly to Linux man pages. RTAI fifos specific services available in kernel and user space are instead explained here.<p>
What is important to remember is that in the user space side you address fifos through the file descriptor you get at fifo device opening while in kernel space you directly address them by their minor number. So you will mate the <em>fd</em> you get in user space by using <div class="fragment"><pre class="fragment"> open(/dev/rtfxx,...) </pre></div>to the integer <code>xx</code> you will use in kernel space.<p>
<dl compact><dt><b>Note:</b></dt><dd>RTAI fifos should be used just with applications that use only real time interrupt handlers, so that no RTAI scheduler is installed, or if you need compatibility with NMT RTL. If you are working with any RTAI scheduler already installed you are strongly invited to think about avoiding them, use LXRT instead.</dd></dl>
It is far better and flexible, and if you really like it the fifos way mailboxes are a one to one, more effective, substitute. After all RTAI fifos are implemented on top of them. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Files</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__fifos_8h.html">rtai_fifos.h</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Interface of the <a class="el" href="group__fifos.html">RTAI FIFO module</a>. <br></td></tr>

<p>
<tr><td class="memItemLeft" nowrap align="right" valign="top">file &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="fifos_8c.html">fifos.c</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Implementation of the <a class="el" href="group__fifos.html">RTAI FIFO module</a>. <br></td></tr>

<p>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga0">rtf_suspend_timed</a> (int fd, int ms_delay)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga1">rtf_open_sized</a> (const char *dev, int perm, int size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga2">rtf_read_all_at_once</a> (int fd, void *buf, int count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga3">rtf_read_timed</a> (int fd, void *buf, int count, int ms_delay)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga4">rtf_write_timed</a> (int fd, void *buf, int count, int ms_delay)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga5">rtf_set_async_sig</a> (int fd, int signum)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga6">rtf_reset</a> (unsigned int minor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga7">rtf_resize</a> (unsigned int minor, int size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga8">rtf_create</a> (unsigned int minor, int size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga9">rtf_destroy</a> (unsigned int minor)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga10">rtf_create_handler</a> (unsigned int minor, int(*handler)(unsigned int fifo))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga11">rtf_put</a> (unsigned int minor, void *buf, int count)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga12">rtf_get</a> (unsigned int minor, void *buf, int count)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ga8" doxytag="fifos.c::rtf_create"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_create           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a real-time FIFO<p>
rtf_create creates a real-time fifo (RT-FIFO) of initial size <em>size</em> and assigns it the identifier <em>fifo</em>. It must be used only in kernel space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>is a positive integer that identifies the fifo on further operations. It has to be less than RTF_NO.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the requested size for the fifo.</td></tr>
  </table>
</dl>
<em>fifo</em> may refer to an existing RT-FIFO. In this case the size is adjusted if necessary.<p>
The RT-FIFO is a character based mechanism to communicate among real-time tasks and ordinary Linux processes. The rtf_* functions are used by the real-time tasks; Linux processes use standard character device access functions such as read, write, and select.<p>
If this function finds an existing fifo of lower size it resizes it to the larger new size. Note that the same condition apply to the standard Linux device open, except that when it does not find any already existing fifo it creates it with a default size of 1K bytes.<p>
It must be remarked that practically any fifo size can be asked for. In fact if <em>size</em> is within the constraint allowed by kmalloc such a function is used, otherwise vmalloc is called, thus allowing any size that can fit into the available core memory.<p>
Multiple calls of this function are allowed, a counter is kept internally to track their number, and avoid destroying/closing a fifo that is still used.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ENODEV</em>&nbsp;</td><td>if fifo is greater than or equal to RTF_NO </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ENOMEM</em>&nbsp;</td><td>if the necessary size could not be allocated for the RT-FIFO. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga10" doxytag="fifos.c::rtf_create_handler"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_create_handler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int(*)(unsigned int fifo)&nbsp;</td>
          <td class="mdname" nowrap> <em>handler</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Install a FIFO handler function.<p>
rtf_create_handler installs a handler which is executed when data is written to or read from a real-time fifo.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>is an RT-FIFO that must have previously been created with a call to <a class="el" href="group__fifos__ipc.html#ga8">rtf_create()</a>.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>handler</em>&nbsp;</td><td>is a pointer on a function wich will be called whenever a Linux process accesses that fifo.</td></tr>
  </table>
</dl>
rtf_create_handler is often used in conjunction with <a class="el" href="group__fifos__ipc.html#ga12">rtf_get()</a> to process data acquired asynchronously from a Linux process. The installed handler calls <a class="el" href="group__fifos__ipc.html#ga12">rtf_get()</a> when data is present. Because the handler is only executed when there is activity on the fifo, polling is not necessary.<p>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO, or handler is <code>NULL</code>.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>rtf_create_handler does not check if FIFO referred by <em>fifo</em> is open or not. The next call of rtf_create will uninstall the handler just "installed". </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga9" doxytag="fifos.c::rtf_destroy"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_destroy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>minor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a real-time FIFO<p>
rtf_destroy closes, in kernel space, a real-time fifo previously created or reopened with <a class="el" href="group__fifos__ipc.html#ga8">rtf_create()</a> or <a class="el" href="group__fifos__ipc.html#ga1">rtf_open_sized()</a>. An internal mechanism counts how many times a fifo was opened. Opens and closes must be in pair. rtf_destroy should be called as many times as rtf_create was. After the last close the fifo is really destroyed.<p>
No need for any particular function for the same service in user space, simply use the standard Unix close.<p>
<dl compact><dt><b>Returns:</b></dt><dd>a non-negative value on success. Actually it is the open counter, that means how many times rtf_destroy should be called yet to destroy the fifo.<p>
a a negative value is returned as described below. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ENODEV</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The equivalent of rtf_destroy in user space is the standard UNIX close. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga12" doxytag="fifos.c::rtf_get"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_get           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read data from FIFO<p>
rtf_get tries to read a block of data from a real-time fifo previously created with a call to <a class="el" href="group__fifos__ipc.html#ga8">rtf_create()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>is the ID with which the RT-FIFO was created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>points a buffer provided by the caller. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>is the size of <em>buf</em> in bytes.</td></tr>
  </table>
</dl>
This mechanism is available only to real-time tasks; Linux processes use a read from the corresponding fifo device to dequeue data from a fifo. Similarly, Linux processes use write or similar functions to write the data to be read via <a class="el" href="group__fifos__ipc.html#ga11">rtf_put()</a> by a real-time task.<p>
rtf_get is often used in conjunction with <a class="el" href="group__fifos__ipc.html#ga10">rtf_create_handler()</a> to process data received asynchronously from a Linux process. A handler is installed via <a class="el" href="group__fifos__ipc.html#ga10">rtf_create_handler()</a>; this handler calls rtf_get to receive any data present in the RT-FIFO as it becomes available. In this way, polling is not necessary; the handler is called only when data is present in the fifo.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the size of the received data block on success. Note that this value may be less than count if count bytes of data is not available in the fifo. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ENODEV</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The equivalent of rtf_get in user space is the standard UNIX read, which can be either blocking or nonblocking according to how you opened the related device. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga1" doxytag="rtai_fifos.h::rtf_open_sized"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_open_sized           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname" nowrap> <em>dev</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>perm</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a real-time FIFO<p>
rtf_open_sized is the equivalent of <a class="el" href="group__fifos__ipc.html#ga8">rtf_create()</a> in user space; it creates a real-time fifo (RT-FIFO) of initial size <em>size</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the requested size for the fifo.</td></tr>
  </table>
</dl>
The RT-FIFO is a character based mechanism to communicate among real-time tasks and ordinary Linux processes. The rtf_* functions are used by the real-time tasks; Linux processes use standard character device access functions such as read, write, and select.<p>
If this function finds an existing fifo of lower size it resizes it to the larger new size. Note that the same condition apply to the standard Linux device open, except that when it does not find any already existing fifo it creates it with a default size of 1K bytes.<p>
It must be remarked that practically any fifo size can be asked for. In fact if <em>size</em> is within the constraint allowed by kmalloc such a function is used, otherwise vmalloc is called, thus allowing any size that can fit into the available core memory.<p>
Multiple calls of this function are allowed, a counter is kept internally to track their number, and avoid destroying/closing a fifo that is still used.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the usual Unix file descriptor on succes, to be used in standard reads and writes. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>if the necessary size could not be allocated for the RT-FIFO.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>In user space, the standard UNIX open acts like rtf_open_sized with a default 1K size. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga11" doxytag="fifos.c::rtf_put"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_put           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write data to FIFO<p>
rtf_put tries to write a block of data to a real-time fifo previously created with <a class="el" href="group__fifos__ipc.html#ga8">rtf_create()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>is the ID with which the RT-FIFO was created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>points the block of data to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>is the size of the block in bytes.</td></tr>
  </table>
</dl>
This mechanism is available only in kernel space, i.e. either in real-time tasks or handlers; Linux processes use a write to the corresponding /dev/fifo&lt;n&gt; device to enqueue data to a fifo. Similarly, Linux processes use read or similar functions to read the data previously written via rtf_put by a real-time task.<p>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes written on succes. Note that this value may be less than <em>count</em> if <em>count</em> bytes of free space is not available in the fifo. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ENODEV</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The equivalent of rtf_put in user space is the standard UNIX write, which can be either blocking or nonblocking according to how you opened the related device. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga2" doxytag="rtai_fifos.h::rtf_read_all_at_once"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_read_all_at_once           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read data from FIFO in user space, waiting for all of them<p>
rtf_read_all_at_once reads a block of data from a real-time fifo identified by the file descriptor <em>fd</em> blocking till all waiting at most <em>count</em> bytes are available, whichever option was used at the related device opening.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>is the file descriptor returned at fifo open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>points the block of data to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>is the size in bytes of the buffer.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes read on success. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>if <em>fd</em> refers to a not opened fifo. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga3" doxytag="rtai_fifos.h::rtf_read_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_read_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ms_delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read data from FIFO in user space, with timeout.<p>
rtf_read_timed reads a block of data from a real-time fifo identified by the file descriptor <em>fd</em> waiting at most <em>delay</em> milliseconds to complete the operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>is the file descriptor returned at fifo open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>points the block of data to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>is the size of the block in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_delay</em>&nbsp;</td><td>is the timeout time in milliseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes read is returned on success or timeout. Note that this value may be less than <em>count</em> if <em>count</em> bytes of free space is not available in the fifo or a timeout occured. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>if <em>fd</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The standard, clumsy, Unix way to achieve the same result is to use select. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6" doxytag="fifos.c::rtf_reset"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_reset           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>minor</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset a real-time FIFO<p>
rtf_reset resets RT-FIFO <em>fd_fifo</em> by setting its buffer pointers to zero, so that any existing data is discarded and the fifo started anew like at its creations. It can be used both in kernel and user space.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>is a file descriptor returned by standard UNIX open in user space while it is directly the chosen fifo number in kernel space.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>0</em>&nbsp;</td><td>on succes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ENODEV</em>&nbsp;</td><td>if <em>fd_fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EINVAL</em>&nbsp;</td><td>if <em>fd_fifo</em> refers to a not opened fifo. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>EFAULT</em>&nbsp;</td><td>if the operation was unsuccessful. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga7" doxytag="fifos.c::rtf_resize"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_resize           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">unsigned int&nbsp;</td>
          <td class="mdname" nowrap> <em>minor</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Resize a real-time FIFO<p>
rtf_resize modifies the real-time fifo fifo, previously created with, <a class="el" href="group__fifos__ipc.html#ga8">rtf_create()</a>, to have a new size of <em>size</em>. Any data in the fifo is discarded.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>minor</em>&nbsp;</td><td>is a file descriptor returned by standard UNIX open in user space while it is directly the chosen fifo number in kernel space.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>is the requested new size.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>on success. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENODEV</em>&nbsp;</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>if <em>fifo</em> refers to a not opened fifo. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-ENOMEM</em>&nbsp;</td><td>if <em>size</em> bytes could not be allocated for the RT-FIFO. Fifo </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>-EBUSY</em>&nbsp;</td><td>if <em>size</em> is smaller than actual content size is unchanged. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga5" doxytag="rtai_fifos.h::rtf_set_async_sig"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_set_async_sig           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>signum</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Activate asynchronous notification of data availability<p>
rtf_set_async_sig activate an asynchronous signals to notify data availability by catching a user set signal signum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>signum</em>&nbsp;</td><td>is a user chosen signal number to be used, default is SIGIO.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>if fd refers to a not opened fifo. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga0" doxytag="rtai_fifos.h::rtf_suspend_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_suspend_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ms_delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Suspend a process for some time<p>
rtf_suspend_timed suspends a Linux process according to <em>delay</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>is the file descriptor returned at fifo open, rtf_suspend_timed needs a fifo support. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_delay</em>&nbsp;</td><td>is the timeout time in milliseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The standard, clumsy, way to achieve the same result is to use select with null file arguments, for long sleeps, with seconds resolution, sleep is also available. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4" doxytag="rtai_fifos.h::rtf_write_timed"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">int rtf_write_timed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname" nowrap> <em>fd</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>void *&nbsp;</td>
          <td class="mdname" nowrap> <em>buf</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ms_delay</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Write data to FIFO in user space, with timeout.<p>
rtf_write_timed writes a block of data to a real-time fifo identified by the file descriptor <em>fd</em> waiting at most @æ delay milliseconds to complete the operation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fd</em>&nbsp;</td><td>is the file descriptor returned at fifo open. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>buf</em>&nbsp;</td><td>points the block of data to be written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>is the size of the block in bytes. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ms_delay</em>&nbsp;</td><td>is the timeout time in milliseconds.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>the number of bytes written on succes. Note that this value may be less than <em>count</em> if <em>count</em> bytes of free space is not available in the fifo. </dd></dl>
<dl compact><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>-EINVAL</em>&nbsp;</td><td>if <em>fd</em> refers to a not opened fifo.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Note:</b></dt><dd>The standard, clumsy, Unix way to achieve the same result is to use select. </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Tue Jan 18 22:53:53 2005 for RTAI API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
